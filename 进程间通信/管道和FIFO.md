**进程间通信(Interprocess Communication,  IPC),  IPC的基本设计目标是高性能**

**FIFO : 有名管道**

- [管道](#管道)
- [FIFO有名管道](#FIFO有名管道)
- [全双工管道](#全双工管道)







## 管道

==**必须保证管道的另一端有人在读取数据, 否则写入会报错,并且也没有任何意义**==

**所有样式的Unix都提供管道, 它由 pipe函数创建, 提供一个单路(单向) 数据流**

==**pipe 管道 (匿名管道)    { 没有对应的磁盘文件 ,就算查看 大小也为0,它存在于内核的一块缓冲区内 }**==

```c
#inlcude <unistd.h>
// 创建匿名管道:
//    建立两个描述符, 并写入 值返回 参数
int pipe(int fd[2]);

/* 参数 :  fd : 管道创建两个文件描述符,会写入这个参数内. fd[0] 用来读, fd[1]用来写,指向同一根管道
  返回值 : 成功返回0, 出错返回 -1
注意事项: 
        父进程读时   -- 父进程关闭写端
        子进程写时   -- 子进程关闭读端
创建两个管道 ,分给两个进程使用, 一个关闭读加写, 一个关闭 写和读, 就可以实现全双工
*/

通过宏 S_ISFIFO  可以确定一个描述符或文件是管道还是 FIFO
    S_ISFIFO的唯一参数是 stat结构的 st_mode 成员. 计算结果为 true或 false.
         对于管道来说 stat结构是 fstat函数填写的.
         对于FIFO来说  stat结构是 fstat , lstat 或 stat 函数填写的.
  


设置为非阻塞:
		//获取原来的 flag 的属性.
		int flags = fcntl(fd[0],F_GETFL); 
		// 设置新的 flags   
		flags |= O_NONBLOCK;  // 将这个属性加入到flags中
		fcntl(fd[0],F_SETFL,flags);    
		// 写上这三句话就可以把你的管道的读端或写端 给他设置成非阻塞的属性



查看管道缓冲区大小:
    命令:  
        ulimit -a 
    函数:
        long fpathconf(fd[0],_PC_PIPE_BUF);     // fd 是管道描述符 , 返回缓冲区大小. 最后参数不用修改.
```

- **管道的读写行为     { 管道默认是阻塞的 }**

    - **读操作**:

        - **管道内有数据** : read(fd) - 正常读,  返回读出的字节数
        - **管道内无数据** : 
            - **写端全部关闭**    : read 解除阻塞, 返回0 , 相当于读文件时,读到了文件的尾部.
            - **写端没有全部关闭** : read 会阻塞, 等待管道被写入数据,然后读取出来.
        - **写操作:**
            - **读端全部关闭**  : 
                - 只有写操作会造成 管道破裂 , 进程被终止.  这个时候内核会给当前进程发信号 SIGPIPE
            - **读端没全部关闭 :**
                - 缓冲区写满了 : write 阻塞,等待缓冲区内的数据被读端取走, 然后他再继续写.
                - 缓冲区没写满 : write 继续写,  等到缓冲区写满 就会阻塞, 这两个状态开始循环触发.

    - **设置为非阻塞:**

        - 默认读写两端都阻塞.  

        - 设置读端为非阻塞 pipe(fd) 的步骤:

            - fcntl - 变参函数:

                - 复制文件描述符 - dup
                - 修改文件属性 - open 的时候对应的 flag 属性.

            - 设置方法: 

                - ```c
                    //获取原来的 flag 的属性.
                    int flags = fcntl(fd[0],F_GETFL); 
                    // 设置新的 flags   
                    flags |= O_NONBLOCK;  // 将这个属性加入到flags中
                    fcntl(fd[0],F_SETFL,flags);    
                    // 写上这三句话就可以把你的管道的读端或写端 给他设置成非阻塞的属性
                    ```

                    



- ==**pipe 管道 (匿名管道)    { 没有对应的磁盘文件 ,就算查看 大小也为0,它存在于内核的一块缓冲区内 }**==
    - **==本质==:  内核缓冲区 (就是一个伪文件,他不占用磁盘空间,操作方式和普通文件是一样的)**
    - ==**特点:**==
        - **内核缓冲区分为两部分(两端):**  
            - 读端 和 写端 ,他们分别对应两个文件描述符.
            - 数据写端流入, 读端流出.
        - **操作管道的进程被销毁之后, 管道占用的存储空间就自动的被释放了.**
        - **管道默认是阻塞的,  读操作和写操作全都是阻塞的.**
    - ==**管道的原理:**==
        - **内部实现方式: 环形队列 的数据结构(对尾插入,对头输出,先进先出)**
        - **==缓冲区的大小==: 默认是 4K ,(大小会根据实际情况做 适当 的调整).**
    - **管道的局限性:**
        - **受限于 队列 的数据结构造成 :  数据只能读取一次, 不能重复读取.** 
        - **半双工** 
            - 单工: 遥控器  , 电视机只能接收, 遥控器只能发送.
            - 半双工: 对讲机 , 数据传输的方向是单向流动的.
            - 双工: 电话 , 双方都可以同时话说和听.
        - **匿名管道:  适用于有血缘关系的进程.  如果没有血缘关系 就不能使用匿名管道.**





## FIFO有名管道

- ==**fifo 管道 (有名管道)   { 在磁盘上有这样一个文件, 有阻塞 }**==

    - **特点: 有名管道**
        - ==**在磁盘上有这样的一个文件, 如果使用 ls -l  来查看  会发现文件属性是 p , 大小为0**==
            - 也是伪文件, 在磁盘上大小永远为0 
        - ==**在内核中有一个对应的缓冲区, 数据就存放在缓冲区中.**==
        - **半双工的通信方式.**

- **使用场景:**

    - **没有血缘关系的进程间通信.**

- **创建方式:**

    - **命令 : mkfifo 管道文件名**
    - **函数 : mkfifo(管道文件名, 该文件的八进制的权限)**
        - **返回0表示成功, -1 表示失败**

- **fifo 文件可以使用 IO 函数进行操作:**

    - **open / close**
    - **read / write**
    - **不能执行 lseek 操作**

- **进程间通信过程伪代码:**

    - ```c
        fifo 文件 -- myfifo
          两个不相干的进程  A(a.out), B(b.out)
          a.out - > read 操作
          		int fd = open( "myfifo" , O_RDONLY );   //就给一个只读权限
        			read(fd,buf, sizeof(buf));  // 如果管道内没有数据,那么就会发生阻塞,等到b.c 来写入.
        			close(fd);
        b.out - > write 操作
          		int fd1 = open( "myfifo" , O_WRONLY);
        			write(fd1, "hello,world",11);
        			close(fd1);
        ```

        

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

// 半双工管道, 只能读 或 只能写.  不可以对管道文件执行 lseek函数, 否则将返回 ESPIPE错误 
//   wirte 会在末尾添加数据,  read 会读取开头的数据
int mkfifo(const char* pathname,  mode_t mode);

/*  参数:  pahtname: Unix路径名,是 FIFO名字,  如果该文件已存在,就返回EEXIST错误. 不存在就创建一个新文件
                       当文件已存在时, 可以改用 open 来打开
              mode: 新文件权限.   文件所有者 S_IRWXU 7, S_IRUSR 4, S_IWUSR 2, S_IXUSR  1
                                   组成员  S_IRWXG 7, S_IRGRP 4, S_IWGRP 2, S_IXGRP 1
                                   其他人  S_IRWXO 7, S_IROTH 4, S_IWOTH 2, S_IXOTH 1
	  返回值: 0 返回值表示成功。 -1 返回值表示错误，错误代码存储在 errno 中。 SIGPIPE信号最多
	  
	  返回成功后, 使用 open 来打开这个文件, 才能真正进行读写.
*/


删除 FIFO有名管道的函数.  谁最后访问 , 就谁来删除

  int unlink(const char *path);

//   参数:  path : mkfifo  的参数
// 返回值 :成功完成后，将返回值 0。否则，返回值 -1 并设置 errno 以指示错误。


设置为非阻塞:
		//获取原来的 flag 的属性.
		int flags = fcntl(fd[0],F_GETFL); 
		// 设置新的 flags   
		flags |= O_NONBLOCK;  // 将这个属性加入到flags中
		fcntl(fd[0],F_SETFL,flags);    
		// 写上这三句话就可以把你的管道的读端或写端 给他设置成非阻塞的属性
```

- **当 write 写入到管道的长度 小于 `PIPE_BUF` 所设置的值时,  内核会保证这次的写操作是原子的**
    - pathconf( ("路径", _PC_PIPE_BUF  )  查看
    - sysconf ( _PC_PIPE_BUF ) 查看
    - setrlimit(RLIMIT_NOFILE,  struct rlimit *rlp ) 修改









