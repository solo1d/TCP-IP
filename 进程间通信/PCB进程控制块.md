- [PCB进程控制块](#PCB进程控制块)
- [获得进程的pid命令](#获得进程的pid命令)
- [执行程序所对应的虚拟地址空间是内核区和用户区](#执行程序所对应的虚拟地址空间是内核区和用户区)
- [孤儿进程和僵尸进程](#孤儿进程和僵尸进程)
- [子进程相关函数](#子进程相关函数)
    - [fork函数](#fork函数)
    - [getpid和getppid函数](#getpid和getppid函数)
    - [exec函数族](#exec函数族)
    - [execl函数](#execl函数)
    - [进程回收函数](#进程回收函数)
        - [wait函数](#wait函数)
        - [waitpid函数](#waitpid函数)
        - 
- 





- **程序和进程**
    - **程序**: 二进制文件, 占用的磁盘空间.  a.out 没有运行,放在磁盘上
    - **进程**: 启动的程序, 占用的内存空间.  a.out 运行了, 加载到内存上  (运行后,就算删除了a.out, 进程还是正常走)

- **并行和并发**
    - **并发**: 一个时间段内,单核处理器所能处理的的请求以及运算.每个进程都会占用时间段内的一部分来运算,然后暂停换下个程序.
    - **并行**: 就是多核处理器在同一个时间段内做同一件事情. (每个处理器都在做并发处理). 





## PCB进程控制块

> 定义的位置在:` LINUX: /usr/include/include/linux/sched.h`  

- **内容如下:**
    - pid(进程ID): 系统中每个进程有一个唯一的ID,在 C语言中用pid_t 类型表示, 其实就是个非负整数.(type unsigned int)
    - 进程的状态 : 有 就绪 , 运行 , 挂起 , 停止  , 初始 五个状态.
        - **初始态**, 就是 ./a.out 刚刚输入,程序正在向就绪态转换的过程.它是所有程序的起点.
        - **就绪态**, 有执行资格,没有执行权限, 准备抢夺cpu资源,但是还没得到cpu.
        - **运行态**, 有执行资格,有执行权限, 得到了cpu资源,而且cpu也正在运行他, 如果他失去cpu那么就会回到 就绪态,继续准备.
        - **挂起态**, 没有执行资格,没有执行权, 失去了cpu, 等待唤醒条件得到满足后就会拥有执行资格,回到就绪态,准备抢cpu.
        - **终止态**, 程序被杀死, 所有的进程状态都可以直接变成终止态.
    - **进程切换时需要保存和恢复的一些CPU寄存器内容和状态.**
    - 描述虚拟地址空间的信息.
    - 描述控制终端的信息. (运行时需要输入和输入,那么就要和终端打交道)
    - 文件描述符表, 包含很多指向file结构体的指针. 可以看成是一个1024的数组, 每个进程最多可以打开1024个文件描述符.
    - 当前工作目录 (Current working Directory)
    - 用户id 和组 id  (stat 文件,  会拿到文件的信息)
    - 会话(Session) 和进程组.  (多个有关联的进程会组成进程组, 多个有关联的进程组可以组成会话)
    - 和信号相关的信息.  (这个信号是 linux 独有, windows 下没有这个)
    - umask 掩码,  他用来做 mode & ~umask  文件权限.
    - **进程可以使用的资源上限.  (通过ulimit -a 命令可以得到一部分资源上限的列表)**

**! 每个进程都有一个内核区, 每个进程的内核区里面都有一个进程控制块,   每启动一个进程,那么在内核区中的 进程控制块就会记录所有的内容.**



## 获得进程的pid命令

```bash 
$ pgrep  程序名     #会获得程序的pid
$ pgrep  -l -      #会得到一个pid列表和程序名称

$ ps  aux | grep  "程序名"    { 得到程序的 pid 和运行状态列表 }
$ ps  ajx | grep  "程序名"    { 得到程序的 pid 和父进程pid  ,比上个更详细 }



```



## 执行程序所对应的虚拟地址空间是内核区和用户区

- 执行程序所对应的 虚拟地址空间包括两个部分: 内核区和用户区
    - 内核区包含:   pcb(进程控制块);
    - 用户区包含:  堆 , 栈,   .text(代码区),  .bss (为初始化全局/静态区) , .data(已初始化全局/静态区), 动态库加载区, env环境变量,   命令行参数 ;





## 孤儿进程和僵尸进程

- **孤儿进程 : 父进程创建子进程.**
    - 但是父进程先结束了,子进程还在存活, 这个子进程 就被称为 孤儿进程.
        - 孤儿被 init 进程领养, init进程变成了 孤儿的父亲.
            - **init 这个操作是为了释放子进程占用的系统资源.**
            - **正常进程结束之后, 能够释放用户区空间.  但是孤儿无法释放 pcb ,必须由父进程释放.** 
- **僵尸进程 : 父进程创建子进程** 
    - 子进程先结束了,但是结束的不彻底, 父进程还在, 但是父进程没有去释放子进程残留的pcb , 
        - **子进程就变成了 僵尸进程.**
        - 但是这个子进程是一个已经死掉的进程,只不过死的状态比较特殊.



子进程相关函数

## fork函数

```c
#include <unistd.h>

fork  { 创建一个子进程  } 
    函数原型:   pid_t fork(void);  
        pid_t 返回值: 他会在两个进程中分返回不同的值.
                     父进程返回子进程pid ,说明现在是在父进程内.
                     子进程返回0  ,      说明现在是在子进程内.
                     创建失败返回-1,      说明现在是在父进程内

    子进程被创建后, 内核区的和用户区是完全拷贝父进程的内容,除了进程ID(就是pid) 不同之外,其他全部相同.
    
    执行位置:  子进程被创建后 
        父进程执行到了哪,子进程就从那个地方开始执行.
    
    执行顺序:
        子进程被创建后,子进程和父进程会同时执行,他们都会去抢夺cpu资源,执行的顺序和cpu 有关系. 用户无法控制,
    
    区分父子进程:
        父进程返回的是子进程的pid (大于0的正整数)  
        子进程返回的是 整数 0  
          
刚fork 出来之后:
     后续各自进行了不同的操作:
        各自进程的地址空间中的数据是完全独立的.互不影响.  ( 子进程和父进程不会执行相同的操作 )
    
    程序内的数据 只读时 共享一块内存.
    当子进程或父进程要修改数据时,会从内存中拷贝一份然后提供给子进程或父进程来使用,  以达到数据的绝对独立性.
    子进程和父进程所有的数据类型(包括全局变量),都不能共享.
    
    main 主函数的父进程的父进程是 bash 这个进程. 也就是前台终端, 它会成为运行程序的父进程.
    pid 为 0 的交换进程是 所有其他进程的祖先进程.
```



## getpid和getppid函数

```c
函数
getpid / getppid   { 得到当前/父进程的PID }
    函数原型 :     pid_t getpid(void);
                  pid_t getppid(void);

        getpid  返回值:  当前 进程的PID
        getppid 返回值:  当前 进程的 父进程的PID  (如果父进程比子进程提前结束,那么他会返回1)
```



## exec函数族

**让父子进程执行互不相干的操作,  能够替换进程地址空间中的源代码,当程序中调用另外一个应用程序 首先想到 exec 之前需要 fork() 一个进程.**



### execl函数

```c
execl()     { 他会替换子进程内部的代码,并且执行传入参数指向的程序,而且也不会回到父进程的轨迹 }
    函数原型: 
      执行指定目录下的程序: int execl (const char* path, const char* arg, ...);

            path   参数: 要执行程序的绝对路径 ,(相对也行), 命令也可以执行,但是需要 /bin/目录下的.
            arg    参数: 随便写点什么,这个参数没用.
            后续的  参数: path执行程序的参数,可以有多个,需要分隔符,写完后必须以 NULL 为结束符号.
    
            返回值     : 程序或命令调用失败,则返回-1  ,但是这个返回值压根没用.
    
    一般用在启动自定义的程序上.而不是执行系统的内容. 比如启动一个自己编写的 a.out 之类的程序.
    
        例: pid_t pid = frok();
            if ( pdi == 0 ){
                execl("/Users/ns/a.out", "a.out", "传入1", "传入2", NULL);  // 执行成功则不执行 perror
                perror ("程序执行失败");                                    // 执行失败 则执行这里.
                exit(1);                   // 这里退出的是子进程,跟父进程无关.   不需要判断返回值,压根没用
            }
            // 调用a.out 然后传入两个参数给他.然后执行.  参数可以写在一起 ,也可以多次传入. 
```



### execlp函数

```c
execlp()    { 执行 PATH 环境变量能够搜索到的程序. 和execl 一样, 只不过他更适合来执行命令 ,而且不需要路径 }
    函数原型: 
        int execlp (const char* command , const char* arg, ... );

            command   参数: 执行的命令的名字.
            其余都和 execl 一样.
    
        使用方法也和 execl 一模一样.
    
        系统的命令一般都在 /bin: /usr/local/bin:    /usr/local/bin:    /usr/sbin:
                        /usr/local/bin:          /usr/bin: /bin:    /sbin
        PATH  个人设置参数在 ~/.bash_profile   在这个文件中.
```



## 进程回收函数

### wait函数

```c
sys/wait.h>
  wait() 这是个阻塞函数,他会等待子进程结束,然后进行回收,如果子进程没有结束,那么会一直阻塞父进程,不让其向下运行.

    函数原型 : pid_t wait (int* status);
参数:   status: 判断子进程是如何死的. 如果对退出状态不关心的话可以写个 NULL,函数会修改传入的参数的值
                               >0 表示正常退出.
                               =0 被某个信号杀死了.
          status 这个参数的具体修改依据是子进程正常结束时 return 和 exit() 的返回值.返回多少就设置成多少.
          
返回值: 如果是被信号杀死的,那么也会返回信号的值 (32个其中的一个,或者系统自定义的更大的数).
        子进程退出状态验证 -- 传入参数 (&status)
            1. WIFEXITED(status);     返回非0 代表成功, 进程正常结束.
               WEXITSTATUS(status);   如果上一条宏返回非0, 那么这个会返回进程退出的状态.
                                      也就是子进程 (exit(), return ) 的参数;
    
            2. WIFSIGNALED(status);  返回非0 代表进程异常终止.
               WTERMSIG(status);     如果上一条宏返回非0 ,那么这个会返回进程终止的那个信号的编号.
                                        就是子进程是被( kill -9 或某个)杀死的.


                返回值:  -1 代表回收失败,  代表的是已经没有子进程了,所有的子进程资源都被回收了.
                        >0 已经回收的子进程的pid.


            调用一次只能回收一个子进程, 每调用一次就回收一次.而且那个子进程结束了,那他就回收哪个,无法指定回收.
    
for(pid_t wpid,int ret; (wpid = wait(&ret)) != -1 ; ){
		printf("循环回收进程\n");
		if(WIFEXITED(ret))   { printf("正常退出 return 或exit 的返回值是 %d",WEXITSTATUS(ret)); }
		if(WIFSIGNALED(ret)) { printf("信号中断 信号编号是 %d",WTERMSIG(ret)); }
	}
```



### waitpid函数

```c
<sys/wait.h>
waitpid       {}
函数原型:   pid_t waitpid(pid_t pid, int* status, int options);

             pid  参数:  pid > 0  : 指定回收的某个子进程的pid.
                        pid = -1 : 回收所有的子进程.(但是每次也只是回收一个.)
                                  需要循环回收,  while( (wpid = waitpid(-1, &status, xx)) != -1 ) 
    
           status 参数: 判断子进程是如何死的. 如果对退出状态不关心的话可以写个 NULL,函数会修改传入的参数的值
                           >0 表示正常退出.
                           =0 被某个信号杀死了.
                  这个参数的具体修改依据是子进程正常结束时 return 和 exit() 的返回值.返回多少就设置成多少.
                  如果是被信号杀死的,那么也会返回信号的值 (32个其中的一个,或者系统自定义的更大的数).
    
           子进程退出状态验证 -- 传入参数 (&status)
               1. WIFEXITED(status);       返回非0 代表成功, 进程正常结束.
                  WEXITSTATUS(status);     如果上一条宏返回非0, 那么这个会返回进程退出的状态.
                                               也就是子进程 (exit(), return ) 的参数;
    
                2. WIFSIGNALED(status);  返回非0 代表进程异常终止.
                   WTERMSIG(status);     如果上一条宏返回非0 ,那么这个会返回进程终止的那个信号的编号.
                                           也就是子进程是被( kill -9 或某个)杀死的.
                  
					3. WIFSIGNALED(status): 如果子进程是因为一个未被捕获的**信号**终止的，那么就返回真
   	         WTERMSIG(status): 返回导致子进程终止的信号的数目，只有在WIFSIGNALED返回真时，才会定义该状态
          
           4. WIFCONTINUED(status)  如果子进程收到 SIGCONT 信号重新启动, 则返回真
                  

            options 参数:
                          0       -  表示waitpid 会阻塞程序.
                          WNOHANG -  表示非阻塞
                          WUNTRACED - 挂起调用进程的执行，知道等待集合中的一个进程变为已终结或被停止。
                          WHOHANG | WUNTRACED - 立即返回，如果等待集合中没有任何子进程被停止或已终止   
                                               ，那么返回0, 否则返回pid
       返回值 : 
                -1  : 回收失败,表示已经没有子进程结束需要回收了, (不包括正在运行的子进程)
                >0  : 被回收的子进程的pid
               如果为非阻塞, options 参数为 WNOHANG 的时候:
                =0  : 子进程处在运行状态.


      最常用的代码规范:     int status;   pid_t wpid;
                          while( (wpid = waitpid(-1,&status, WNOHANG)) != -1 ){
                              if(wpid == 0){ 
                                continue;     // 如果有子进程还活着就进入这里,等待子进程死亡
                              }
                              printf("... child died pid = %d\n",wpid);  // 已经死亡子进程id
                              if(WIFEXITED(status)){                    // 判断是不是正常结束
                                printf("return value %d\n",WEXITSTATUS(status));
                              }
                              else if(WIFSIGNALED(status)){             // 判断是不是异常结束
                                printf("died by signal: %d\n",WTERMSIG(status));
                              }
                          }
```







