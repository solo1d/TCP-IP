
协议:  { 其实就是我们自定义的通信规则,每个包的具体位置是做什么的 }
    ftp  : f文件, t传输, p协议    ,文件传输协议




以下都是网络基础:

1.网络应用程序设计模式: (架构)
    C/S - client/server  - 客户端/服务端    {qq, 微信,客户端游戏 ,提供桌面客户端都是这个设计模式 }
        优点: 1. 协议选用灵活,        2. 可以缓存数据
        缺点: 1. 对用户安全构成威胁,   2. 开发工作量大, 调试困难

    B/S - browser.server  - 浏览器/服务端   { 只要有浏览器就行 }
        优点: 跨平台
        缺点: 只能使用 http 协议来实现

2.协议的概念
    规则: 数据传输和数据解释的规则
    原始协议 --->(改进,完善)----> 标准协议
    典型协议: TCP/UDP  HTTP  FTP  IP  ARP 

3.模型:  { 一般说模型的时候 说的是 TCP的四层模型. }
    OSI 七层模型:  物数网传会表应
        底层 --  物 - 物理层     --- 双绞线,光纤
                数 - 数据链路层  --- 数据的传输和二进制数据校验
                网 - 网络层     --- 为数据包选择路由
                传 - 传输层     --- 提供端对端的接口
                会 - 会话层     --- 解除或建立与别的节点的联系
                表 - 表示层     --- 数据格式化, 代码转换, 数据加密
        上层 --  应 - 应用层     --- 文件传输, 电子邮件, 文件服务, 虚拟终端 

    TCP/IP 四层模型 : 
               数据链路层(包括了物理层) - 包括的协议有 以太网帧协议 (这些协议用的最多,而不是只有这一个)
               网络层                -   IP 协议
               传输层                -   TCP/UDP 协议
               应用层(包括了 会,表,应) -   ftp , HTTP, ssh 协议
    我们程序猿只关心和处理 应用层 的协议.(也要自定义). (剩下的都是操作系统处理的,不需要人为操作)

4.TCP,UDP 传输层协议
    TCP : 面向连接 的安全的 流式传输协议.   (效率低, 一般用在文件和密码文件上 ,很安全)
            连接的时候, 自动进行三次握手. 客户端发起握手请求, 服务端等待被请求握手.
            数据发送的时候,会进行数据确认.
                数据丢失之后, 会进行数据重传.

    UDP : 面向无连接 的不安全的 报式传输.   (效率高, 安全低, 可以在应用层自定义的进行效验)
            连接的时候不会握手.
            数据发送出去之后就不管了.
                如果数据包丢失 会全丢, 不存在丢失一半的情况.
   
    滑动窗口   
        就是缓冲区.
        win 4096
            win  - 标识位,代表滑动窗口
            4096 - 滑动窗口对应的缓冲区的大小. 每个系统和网卡都是不同的.

        每次接受数据,都会存放在滑动窗口中, 然后程序进行处理.

    ----------------
    TPC 的三次握手
        标志位:  {一共有6个, 每个标志位占一个字节}
            SYN : 请求建立连接
            ACK : 应答
            FIN : 断开连接  (四次挥手会使用)
            编号 : 对方最后发送ACK 的时候携带的确认序号.
            win : 滑动窗口
        握手过程:
            第一次握手
                客户端: 发起请求建立链接, 携带SYN标志位, 后面加上一个32位的随机序号, 可以携带数据(一般不带).
                        mss是接收每个包的最大数据长度.(不是总长度) 如果携带数据,则确认序号会另行计算. 
                        SYN 100 (0)  mss 1460 // SYN标志位为1, 数据长度是0, 
                                              // 服务器给我发包的时候,数据最大只能是1460 字节

                服务器: 检测SYN 的值是否为1, 如果不是1 则拒绝请求.检测mss长度,然后查看自己mss长度.

            第二次握手
                服务器: 发送 ACK标志位 + 确认序号(客户端32位随机序号+1 {例 100+1=101 }),(这个1是ACK ) 
                        如果携带数据,则将数据占的字节数 加到32位随机序号中,{例,携带20字节数据 100+20 = 120}
                       和一个连接请求 SYN+32位新的随机序号. mss接收的每个包的最大数据长度
                        SYN 200(0) ACK 101   mss 1024 // SYN标志位为1, 数据长度0, 序号100+1 =101确认序号
                                                      // 客户端给我 发数据的时候, 数据长度最大只能 1024字节

                客户端: 检测标志位 ACK 是否为1, 为1则正确,否则拒绝. 查看mss,
                        效验32位的 确认序号是否正确. 第二次握手成功.

            第三次握手
                客户端: 发送一个确认数据包 , ACK 加确认序号(服务器发过来的32位随机序号+1)
                        101(0) ACK 201

                服务器: 检测ACK 是否为1, 效验32位的 确认序号是否正确. 第三次握手成功.
                        // 不回复  ,如果回复的话 就是数据发送过程了, 和握手无关

    ----------------
    TPC 的四次挥手
        两端都可以主动断开连接.
        需要标志位 FIN
        断开连接在程序中的表示是 服务器close(),客户端close(),就会自动进行四次挥手.
        
        断开连接过程:
            第一次挥手 
                    客户端发起挥手请求, 发送FIN+编号 和 ACK+确认序号
                        FIN 201(0) ACK 101
                    
                    服务器验证FIN 是否为1,验证ACK的作用是告诉对方之前发的数据收到了多少,(如果缺少,客户端会重发)
            
            第二次挥手
                    服务器 给客户端确认数据包. ACK + 确认序号 +1 (FIN标志位)
                            ACK 202

                    客户端 收到数据包之后,确认ACK和确认序号, 查看有没有数据包丢失.

            第三次挥手
                    服务器发起挥手请求,给客户端发送 FIN+编号 和 ACK+确认序号
                        FIN 101(0) ACK 202

                    客户端 验证ACK是否为1, 验证ACK .

            第四次挥手
                    客户端 给服务端确认数据包, ACK + 确认序号 +1 (FIN标志位)
                        ACK 102

                    服务端 收到数据包,确认ACK和确认序号, 然后完成第四次挥手, 双方无数据发送了.



        ----------------
        TCP 状态转换
            <第一次握手>
            Server 启动后立刻从 CLOSE状态 进入 LISTEN状态(listen()),等待客户端连接.
            Client 启动后立刻从 CLOSE状态 进入 SYN_SENT状态(connect()), 给服务器发送 SYN+随机序号+数据

            <第二次握手和第三次握手>
            Server 收到客户端的SYN后,验证通过, 进入SYN——RCVD状态, 然后发送 SYN+随机序号 +ACK+确认序号+数据
            Client 收到服务端的SYN和ACK之后, 验证, 通过则进入 ESTABLISTHED状态, 然后发送 ACK+确认序号+数据
            Server 收到客户的的ACK之后, 验证,通过则进入 ESTABLISTHED状态 ,(这个状态和客户端相同)

            <通信>
            无状态

            <第一次挥手>
            Client 先向服务器发送 FIN 编号+ACK+确认序号+数据, 然后进入FIN_WAIT_1 状态, ,请求断开连接
            <第二次挥手>
            Server 收到FIN之后,进入CLOSE_WAIT状态, 然后向客户的回复 ACK+确认序号+数据
            Client 收到ACK之后,进入FIN_WAIT_2 状态.(客户端进入半关闭状态,(只能收不能发))
            <第三次挥手>
            Server 进入LAST_ACK状态(close()触发的), 然后向客户端再次发送 FIN+编号
            <第四次挥手>
            Client 收到FIN之后,进行验证. 然后进入TIME_WAIT状态. 向服务端发送 ACK+确认序号.(连接结束)


        ----------------
        半关闭
            - A给 B发送是 FIN(A调用了colse 函数), 但是B 没有给A 发送FIN(B没有调用close 函数).
            - A断开了与B 的连接 , 但是B  没有断开与 A 的连接.

            特点: (A断开了与B的连接, 但是B没有断开与A的连接,为前提)
                A不能给B 发送数据, 但是A 可以收到B 发送的数据.
                B可以给A 发送数据, (A也无法回复ACK).
            函数:
                int shutdown( int sockfd, int how);   // 专业函数, 到时候不需要记
                    sockfd 参数: 套接字文件描述符
                    how    参数:  SHUT_RD   =0 关闭 读
                                 SHUT_WR   =1 关闭 写
                                 SHUT_RDWR =2 关闭读写

                close 也可以实现半关闭,
                    dup2(sockfd, fd);   // 复制套接字文件描述
                    close(fd);          // 关闭复制的这个, 然后继续使用sockfd 来通信.


    主动断开连接的一方, 会在程序结束后, 占用他所用来通讯的端口一分钟,一分钟之后自动释放.
    被动断开的一方, 会直接结束,释放端口.
        

        ----------------
        查看网络相关状态信息
            命令: netstat
            参数:  -a  (all)显示所有选项, 默认是不显示LISTEN(监听)相关,加了-a 就显示了.
                  -p   显示建立相关链接的程序名.
                  -n   拒绝显示别名, 能显示数字的全部转化成数字.
                  -t   (TCP) 仅显示 TCP 相关选项.
                  -u   (UDP) 仅显示 UDP 相关选项.
                  -l    仅列出 处在Listen(监听)状态 的服务状态.

            一般情况使用 
                netstat -apn| grep 端口号   // MAC 是例外,需要另行百度.
             

-------------------------------------------


端口:
        主动断开连接的一方, 会在程序结束后, 占用他所用来通讯的端口一分钟,一分钟之后自动释放.
        被动断开的一方, 会直接结束,释放端口.


     端口复用:
            端口复用最长的用途是:
                - 防止服务器重启时之前绑定的端口还未释放.
                - 程序突然退出 而系统没有释放端口.

            设置端口复用的方法:
                int opt = 1;                    // 固定格式. 名字可以变
                setsockopt( int sockfd,         // 监听用的套接字 文件描述符,
                            SOL_SOCKET,         // 直接填写这个参数,后面所有参数都是固定格式.
                            SO_REUSEADDR      , // 这个也是固定的宏参数
                            (const void*)&opt ,  // 这个就是opt 取地址然后强转
                            sizeof(opt));        // opt 的大小

                注意事项:
                    需要在端口绑定之前设置端口复用.(bind());
