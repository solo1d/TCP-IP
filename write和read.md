# write返回值

## 1、返回值>0

a、等于给定字节数

b、小于给定字节数，有如下几种可能：

底层物理介质上没有足够的空间
创建的文件指定了RLIMIT_FSIZE，也就是指定了文件允许的最大字节数，不能再往其中添加数据
已经写了部分数据，但是被中断信号打断，返回中断打断前写入的字节数



## 2、返回值=0

如果相应的errno被设定，说明有相应失败情况。如果errno没有被设定，没有任何影响（可能是write 指定写入0字节等）。这和read返回0不一样，read返回0意味着对端close。其实这些都是为了保持与read/write文件保持一致，因为在读写文件的时候read总会读到文件结束EOF，返回0；但是只要没有磁盘等的限制，write可以一直写下去。



## 3、返回值<0(-1)

出错，查看errno：

EAGAIN or EWOULDBLOCK：fd被设定为非阻塞，并且write将会被阻塞，立即返回-1，errno为EAGAIN
EINTR：a、阻塞fd：被一个信号打断，但是需要强调的是，在信号打断前没有写入一个字节，才会返回-1，errno设定为EINTR。如果有写入，返回已经写入的字节数。这其实很好理解，如果写入了部分数据依然返回-1，errno设定为EINTR，处理完中断后，由于不知道被打断时写到了什么地方，也就不知道该从哪一个地方继续写入。b、非阻塞fd：调用非阻塞write，即使write被信号打断，write会会继续执行未完成的任务而不会去响应信号。因为在非阻塞调用中，没有任何理由阻止read或者wirte的执行。
EPIPE：fd是一个pipe或者socket，而对端的读端关闭。但是一般而言，写进程会收到SIGPIPE信号。（注意：和read不一样，read对端关闭使返回0）

# read返回值



## 1、返回值>0

a、等于给定字节数

b、小于给定字节数，可能原因如下：

在读到小于指定字节数时就已经收到了EOF，返回已经读到的数据
在读入部分数据时，被信号打断，返回已经读到的数据



## 2、返回值=0

说明读到文件尾EOF，或者socket的对端关闭。



## 3、返回值<0（-1）

查看errno：

EAGAIN or EWOULDBLOCK：fd设定为非阻塞，且要被阻塞时立即返回-1，设定相应的errno
EINTR：a、阻塞fd：如果在读入任何数据之前被打断，返回-1。如果被打断前读入了部分数据，返回已经读入的数据字节数。b、非阻塞fd：调用非阻塞read，即使read被信号打断，read会会继续执行未完成的任务而不会去响应信号。因为在非阻塞调用中，没有任何理由阻止read或者wirte的执行。





# 非阻塞

- **套接字的默认状态是阻塞的, 当发出一个不能立即完成的套接字调用时, 其进程将被置于休眠状态, 等待相应操作完成**
- **可能阻塞套接字调用分为以下四类:**
  - 输入操作  `read , readv, recv, recvfrom , recvmsg`, 对于非阻塞套接字,如果无数据到达会直接返回EWOULDBLOCK 错误
  - 输出操作 `write,  writev, send, sendto, sendmsg` ,对于非阻塞套接字,如果其TCP发送缓冲区没有空间会返回 EWOULDBLOCK 错误,  UDP不存在真正的发送缓冲区.
  - 接收外来连接, 即 `accept` 函数, 对于非阻塞套接字, 并且尚无新的连接到达,accept将立即返回一个EWOULDBLOCK 错误
  - 发起外出连接, 即 `connect` 函数, 会一直等到完成三次握手之后才会返回. 对于非阻塞套接字 连接会照常发起(例如只送出一个SYN) ,只不过会返回一个 EINPROGRESS错误, 也可能会成功返回.

